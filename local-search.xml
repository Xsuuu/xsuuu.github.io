<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端三件套笔记补充</title>
    <link href="/2026/01/27/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/"/>
    <url>/2026/01/27/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1>HTML<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">用<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>空一行   <br>用<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>在不产生一个新段落的情况下换行<br>用<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>画一条水平线分割，可以用color，width，size，align调整颜色，宽度，高度，对齐方式<br>在<span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span>中alt是图片未加载出来的提示，title是鼠标悬停时的提示<br></code></pre></td></tr></table></figure><p><img src="/img/cr/%E4%B8%89%E4%BB%B6%E5%A5%97/1.png"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;超链接<br></code></pre></td></tr></table></figure><p><img src="/img/cr/%E4%B8%89%E4%BB%B6%E5%A5%97/2.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xquery">有序列表<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;1/a/A/i/I&quot;</span>&gt;</span></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二个<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></span><br>ol换成ul就是无序列表(type=<span class="hljs-string">&quot;disc实心圆/circle空心圆/square小方块/none不显示&quot;</span>)<br><br>表格<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>(border)</span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>内容1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>内容2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br>快捷键“table&gt;tr*<span class="hljs-number">2</span>&gt;td*<span class="hljs-number">2</span>&#123;内容&#125;”<br>水平合并:colspan=<span class="hljs-string">&quot;2&quot;</span>;垂直合并:rowspan=<span class="hljs-string">&quot;2&quot;</span><br><br>表单：<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;服务器url&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get/post&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sth&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>表单元素:type=<span class="hljs-string">&quot;text/submit/password&quot;</span>,<span class="hljs-keyword">value</span>=<span class="hljs-string">&quot;登录&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/cr/%E4%B8%89%E4%BB%B6%E5%A5%97/3.png"></p><p><img src="/img/cr/%E4%B8%89%E4%BB%B6%E5%A5%97/4.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">新标签有兼容问题，所以很多还是用的<span class="hljs-keyword">div</span>（？？？）<br></code></pre></td></tr></table></figure><h1>CSS<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">index里面引入css用&lt;link rel=<span class="hljs-string">&quot;默认不管&quot;</span> href=<span class="hljs-string">&quot;./111.css&quot;</span>&gt;<br>选择器:* 全局选择器，p/ul/li/div.<span class="hljs-string">.....</span> 元素选择器，<span class="hljs-string">.classname</span> 类选择器，<span class="hljs-comment">#idname ID选择器</span><br>合并选择器：例如：<span class="hljs-string">.header</span>,<span class="hljs-string">.footer</span>&#123;&#125;<br>选择器的优先级：内联选择器<span class="hljs-params">(1000)</span>&gt;id选择器<span class="hljs-params">(100)</span>&gt;类选择器<span class="hljs-params">(10)</span>&gt;元素选择器<span class="hljs-params">(1)</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">字体属性：<span class="hljs-attribute">color</span>，<span class="hljs-attribute">font-size</span>，<span class="hljs-attribute">font-weight</span>(字体粗细)，<span class="hljs-attribute">font-style</span>，<span class="hljs-attribute">font-family</span><br>背景属性：<span class="hljs-attribute">background-color</span>,<span class="hljs-attribute">background-image</span>,<span class="hljs-attribute">background-position</span>(设置背景图片的起始位置),<span class="hljs-attribute">background-repeat</span>(往哪方向重复或者不重复，默认水平垂直方向都平铺),<span class="hljs-attribute">background-size</span>(可以保持原尺寸)<br>文本属性：<span class="hljs-selector-tag">text</span><span class="hljs-built_in">-aligh</span>(文本对齐方式),<span class="hljs-selector-tag">text</span><span class="hljs-built_in">-decoration</span>(文本装饰，比如上下划线，删除线等)，<span class="hljs-selector-tag">text</span><span class="hljs-built_in">-transform</span>(控制文本的大小写，包括首字母大写，或者全大写全小写)，<span class="hljs-selector-tag">text</span><span class="hljs-built_in">-indent</span>(首行缩进多少)<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">表格属性：(<span class="hljs-attribute">width</span>,<span class="hljs-attribute">height</span>,<span class="hljs-selector-tag">text</span>-aligh(水平对齐方式),vertical-aligh(垂直对齐方式)，<span class="hljs-attribute">padding</span>(单元格内空白长度)，<span class="hljs-attribute">background-color</span>)<br>表格边框:table,td&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span>,solid,black&#125;<br>折叠边框:table&#123;<span class="hljs-attribute">border-collapse</span>&#125;(双边框变成单边框)<br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">后代选择器：<span class="hljs-built_in">E</span> <span class="hljs-variable">F</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>所有被<span class="hljs-built_in">E</span>元素包含的<span class="hljs-variable">F</span>元素<span class="hljs-punctuation">)</span><br>子代选择器：<span class="hljs-built_in">E</span><span class="hljs-operator">&gt;</span><span class="hljs-variable">F</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#123;</span>只对<span class="hljs-built_in">E</span>元素的直接子元素<span class="hljs-variable">F</span>有效<span class="hljs-punctuation">&#125;</span><br>相邻兄弟选择器：<span class="hljs-built_in">E</span><span class="hljs-operator">+</span><span class="hljs-variable">F</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span>只对紧跟<span class="hljs-built_in">E</span>元素后的第一个<span class="hljs-variable">F</span>元素有效<span class="hljs-punctuation">)</span><br>通用兄弟选择器：<span class="hljs-built_in">E</span><span class="hljs-operator">~</span><span class="hljs-variable">F</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">E</span>元素后的所有<span class="hljs-variable">F</span>元素<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/img/cr/%E4%B8%89%E4%BB%B6%E5%A5%97/5.png"></p>]]></content>
    
    
    <categories>
      
      <category>三件套</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记9</title>
    <link href="/2025/08/10/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/"/>
    <url>/2025/08/10/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05/</url>
    
    <content type="html"><![CDATA[<h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><blockquote><h5 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h5><blockquote><p><strong>并发</strong>：两个或多个时间在同一时间段内发生(交替执行)</p><p><strong>并行</strong>：两个或多个时间在同一时刻发生(同时执行)</p><p><img src="/img/cr/Java-SE/61.png"></p></blockquote><h5 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h5><blockquote><p><strong>进程</strong>：是指一个内存中运行的应用程序</p><p><img src="/img/cr/Java-SE/62.png"></p><p><strong>线程</strong>：进程中的一个执行单元，复制当前进程中程序的执行，一个进程中至少有一个线程</p><p><img src="/img/cr/Java-SE/63.png"></p><p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程</p></blockquote><p><strong>线程调度</strong>：</p><blockquote><p><strong>分时调度</strong>：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间</p><p><strong>抢占式调度</strong>：有限让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p></blockquote><p>主线程：执行主(main)方法的线程</p><p>单线程程序：Java程序中只有一个线程，执行从买方法开始，从上到下依次执行</p><p><img src="/img/cr/Java-SE/64.png"></p><h5 id="常见线程类Thread"><a href="#常见线程类Thread" class="headerlink" title="常见线程类Thread"></a>常见线程类Thread</h5><p><img src="/img/cr/Java-SE/65.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;run &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">mt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        mt.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;main &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><blockquote><h5 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h5><p><img src="/img/cr/Java-SE/66.png"></p><p><strong>使用run方法和使用start方法的区别</strong>：</p><blockquote><p>使用run方法，相当于在执行main方法的栈里面再压栈执行run方法；而使用start方法，相当于在执行main方法的栈之外<strong>再开辟一个新的栈空间</strong>，而run方法在开辟的新的栈空间中压栈执行。</p><p>cpu就有了选择的权利，因为在不同的栈空间中，多个线程之间互不影响</p></blockquote><p><strong>Thread类中的常用方法</strong>:</p><blockquote><p><strong>获取线程的名称的方式</strong>：1.直接使用getName()方法;2.先使用currentThread()获取当前线程，再使用getName()方法</p><p><strong>设置线程的名称</strong>：1.直接使用setName()方法；2.使用带参数的构造方法</p><p><strong>public static void sleep(long millis)</strong>:使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSleepMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">60</span>; i++) &#123;<br>            System.out.println(i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>线程的名称：主线程：main；新线程默认名称：Thread-0&#x2F;Thread-1&#x2F;Thread-2……</p><h5 id="创建多线程程序的第二种方式-通过Runnable接口-："><a href="#创建多线程程序的第二种方式-通过Runnable接口-：" class="headerlink" title="创建多线程程序的第二种方式(通过Runnable接口)："></a>创建多线程程序的第二种方式(通过Runnable接口)：</h5><blockquote><p><img src="/img/cr/Java-SE/67.png"></p><p><img src="/img/cr/Java-SE/68.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;   &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableImpMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableImp</span> <span class="hljs-variable">ri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableImp</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(ri);<br>        t.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;   &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>用匿名内部类方式实现线程的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类/接口()&#123;<br>    重复父类/接口中的方法<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClassThreadMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><blockquote><p>多线程访问共享数据会产生线程安全问题</p><p>要解决线程安全问题，必须让一个线程在访问共享数据的时候，无论是否失去了cpu的执行权，其他的线程只能等待当前线程执行完才能执行。</p><h5 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h5><blockquote><p>同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(锁对象)&#123;<br>需要同步操作的代码<br>&#125;<span class="hljs-comment">//必须保证多个线程使用的锁对象是同一个</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span>(obj)&#123;&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/69.png"></p><p>同步保证了只有一个线程在同步中执行共享数据，保证了安全，但是程序频繁地判断锁，获取锁，释放锁，程序的效率会降低</p><p>同步方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>可能会产生线程安全问题的代码<br>&#125;<br><span class="hljs-comment">//同步方法会把方法内部的代码锁住，只让一个线程执行，锁对象也就是实现类对象 new RunnableImp()，也就是this</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payTicket</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-number">111</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payTicket</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (Runnable.class)&#123;<br>            <span class="hljs-number">111</span><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//静态同步方法也可以保证安全，方法加static，变量也要是static变量。对象不能是this，因为this是创建对象后产生的，静态方法优于对象。静态方法的锁对象是本类的class属性-&gt;class文件对象(反射)</span><br></code></pre></td></tr></table></figure><p>Lock锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>l.lock();<br>l.unlock();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketImp3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">ticket</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            l.lock();<br>            <span class="hljs-keyword">if</span>(ticket &lt;= <span class="hljs-number">100</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                    System.out.println(getClass().getName() + <span class="hljs-string">&quot; &quot;</span> +Thread.currentThread().getName() + <span class="hljs-string">&quot;正在卖第&quot;</span> + ticket + <span class="hljs-string">&quot;张票&quot;</span>);<br>                    ticket ++;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    l.unlock();<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l.unlock();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记4</title>
    <link href="/2025/08/07/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/"/>
    <url>/2025/08/07/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    
    <content type="html"><![CDATA[<h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.addAll(array,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<span class="hljs-comment">//往集合中添加一些元素</span><br>Collections.shuffle(array);<span class="hljs-comment">//打乱集合顺序</span><br>Collections.sort(array);<span class="hljs-comment">//将集合中的元素按照默认规则进行排序，默认是升序，静态方法，只能传List集合，不能传Set集合</span><br></code></pre></td></tr></table></figure><p>sort被排序的集合里边存储的元素，必须实现Comparable，重写接口中的方法compareTo定义排序的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getAge() - o.getAge();<span class="hljs-comment">//年龄升序排序</span><br>        <span class="hljs-comment">//return o.getAge() - this.getAge();//年龄降序排序</span><br>    &#125;<br>&#125;<span class="hljs-comment">//别忘了重写toString方法</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>Comparable</strong>:自己和别人比较，自己需要实现Comparable接口，重写比较的规则compareTo方法</p><p><strong>Comparator</strong>:相当于找一个第三方的裁判，比较两个</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.sort(array, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o1-o2;<span class="hljs-comment">//升序</span><br>                <span class="hljs-comment">//return o1 - o2;//降序</span><br>            &#125;<br>        &#125;);<span class="hljs-comment">//也可以排序自定义类</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person o1, Person o2)</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> o1.getAge()-o2.getAge();<span class="hljs-comment">//升序</span><br>                <span class="hljs-comment">//return o1 - o2;//降序</span><br>                <span class="hljs-keyword">if</span>(result == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> o1.getName().charAt(<span class="hljs-number">0</span>) - o2.getName().charAt(<span class="hljs-number">0</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="Map集合"><a href="#Map集合" class="headerlink" title="Map&lt;K,V&gt;集合"></a>Map&lt;K,V&gt;集合</h5><blockquote><h5 id="Map集合-1"><a href="#Map集合-1" class="headerlink" title="Map集合"></a>Map集合</h5><blockquote><p>1.双列集合，一个元素包含两个值(key,value)，key和value一一对应</p><p>2.key和value的数据类型可以相同，可以不同；key值不允许重复，value值可以重复</p><p>3.Map集合保证key是唯一的：作为key的元素，必须重写hashCode和equals方法，以保证key唯一</p></blockquote><h5 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h5><blockquote><p>1.底层是哈希表，查询速度特别快，jdk1.8前后：数组＋单向链表&#x2F;红黑树(链表的长度超过8):提高查询的速度</p><p>2.无序的集合，存储和取出元素的顺序有可能不一致</p><p>3.HashSet就是只有key参数的HashMap,所以他的参数不允许重复</p></blockquote><p><strong>HashTable</strong>:不能存储null值和null键，和Vector一样，再jdk1.2版本之后被更先进的集合(HashMap，ArrayList)取代了，但是Hashtable的子类Properties依然活跃在历史舞台</p><p>properties集合是唯一和IO流相结合的集合</p><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><blockquote><p>1.底层是哈希表＋链表(保证迭代的顺序)</p><p>2.有序的集合，存储和取出元素的顺序是一致的</p><p>3.和HashMap集合相似的，LinkedHashSet是只有key参数的LinkedHashMap，他的参数也不允许重复</p></blockquote><p><img src="/img/cr/Java-SE/54.png"></p><p>存储键值对时，key不重复直接存入，key重复替代原有value值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer,String&gt; map =<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>键值对数据类型最好用包装类，因为取出时可能是null值，不是包装类就会产生空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set = map.keySet();<br>Iterator&lt;Integer&gt; itrt = set.iterator();<br><span class="hljs-keyword">while</span>(itrt.hasNext())&#123;<br>     <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> itrt.next();<br>     System.out.println(map.get(key));<br>&#125;<br><span class="hljs-keyword">for</span>(Integer i:set) &#123;<br>     <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(i);<br>     System.out.println(value);<br>&#125;<span class="hljs-comment">//可使用Iterator和增强for遍历</span><br></code></pre></td></tr></table></figure><p>1.使用Map集合中的方法keySet()，把Map集合中所有的key取出存储到一个Set集合中</p><p>2.遍历Set集合为Map集合的key，通过get(key)方法遍历value</p><h5 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h5><p>当Map集合一创建，那么就会在Map集合中创建一个Entry对象，用来记录键与值(键值对对象，键与值的映射关系)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">EntrySet()<span class="hljs-comment">//把map集合内部的多个Entry对象取出来存储到一个Set集合中,再遍历Set集合中的每一个entry对象</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();<br><span class="hljs-type">Iterator</span> <span class="hljs-variable">itrt</span> <span class="hljs-operator">=</span> set.iterator();<br><span class="hljs-keyword">while</span>(itrt.hasNext())&#123;<br>      System.out.println(itrt.next());<br>&#125;<br><span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry:set)&#123;<br>      System.out.println(entry);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="of-方法"><a href="#of-方法" class="headerlink" title=".of()方法"></a>.of()方法</h5><blockquote><p><img src="/img/cr/Java-SE/55.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote><h5 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h5><blockquote><p><img src="/img/cr/Java-SE/56.png"></p><ol><li>f8：逐行执行程序</li><li>f7：进入到方法中</li><li>shift+f8：跳出方法</li><li>f9：跳到下一个断点，如果没有下一个断点，就结束程序</li><li>ctrl+f2：退出debug模式，停止程序</li><li>Console：切换到控制台</li></ol></blockquote><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><blockquote><p>异常指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止</p><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象(包含了异常产生的内容、原因和位置)。java处理异常的方式是中断出来</p><p>异常指的并不是语法错误，语法错了，编译不通过，不会产生字节码文件，根本不能运行</p><p><img src="/img/cr/Java-SE/57.png"></p><h5 id="处理异常的逻辑："><a href="#处理异常的逻辑：" class="headerlink" title="处理异常的逻辑："></a>处理异常的逻辑：</h5><p><img src="/img/cr/Java-SE/58.png"></p><h5 id="抛出异常throws："><a href="#抛出异常throws：" class="headerlink" title="抛出异常throws："></a>抛出异常throws：</h5><blockquote><p><img src="/img/cr/Java-SE/59.png"></p><p>首先必须对方法传递过来的参数进行合法性校验，如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(arr == <span class="hljs-literal">null</span>)&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;传递的数组为空&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>NullPointerException空指针异常、ArrayIndexOutOfBoundsException超出索引异常都是运行期异常，我们不用处理，默认交给JVm处理</p></blockquote><h5 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Objects.requireNonNull(obj);<br>Objects.requireNonNull(obj,<span class="hljs-string">&quot;111&quot;</span>);<span class="hljs-comment">//可以替换上面那个代码块中的内容</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="Throws声明异常"><a href="#Throws声明异常" class="headerlink" title="Throws声明异常"></a>Throws声明异常</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数列表) <span class="hljs-keyword">throws</span> AAAException,BBBException...&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AAAException</span>(<span class="hljs-string">&quot;产生原因&quot;</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BBBException</span>(<span class="hljs-string">&quot;产生原因&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果抛出的多个异常是子类父类关系，直接声明父类异常即可</p><p>调用了声明抛出异常的方法，就必须处理声明的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sus</span><span class="hljs-params">(String str)</span> <span class="hljs-keyword">throws</span> IOException&#123;<span class="hljs-comment">//IOException是父类，直接用Exception也可以，他是所有异常的父类</span><br> <span class="hljs-keyword">if</span>(!str.equals(<span class="hljs-string">&quot;c:\\\\a.txt&quot;</span>))&#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>(<span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">if</span>(!str.endsWith(<span class="hljs-string">&quot;.txt&quot;</span>))&#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br>&#125;<span class="hljs-comment">//main函数方法定义处也要throw出来这个异常</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try_catch"></a>try_catch</h5><blockquote><p>自己处理异常，后续代码可以执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>可能产生异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类名 变量名(定义一个异常变量，用来接受<span class="hljs-keyword">try</span>中抛出的异常对象)&#123;<br>异常的处理逻辑，抛出异常对象后，怎么处理异常对象<br>一般在工作中，会把异常信息记录到一个日志中<br>&#125;<br><span class="hljs-keyword">try</span>&#123;<br>   <span class="hljs-number">111</span>;<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>   System.out.println(e);<br>&#125;finall&#123;<br> 无论是否存在异常都会执行<br>&#125;<br></code></pre></td></tr></table></figure><p>try中产生了异常，才会执行异常的处理逻辑</p></blockquote><h5 id="Throwable中的一些查看方法"><a href="#Throwable中的一些查看方法" class="headerlink" title="Throwable中的一些查看方法"></a>Throwable中的一些查看方法</h5><blockquote><p><img src="/img/cr/Java-SE/60.png"></p></blockquote><p><strong>finally代码块</strong>：必须和try一起使用，所以一般用于资源释放，无论程序是否出现异常，最后都要资源释放(IO)</p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><blockquote><p>多异常捕获： 1.分别处理(一个异常，一个try catch) 2.一次捕获，多次处理(一个try，多个catch) (catch里定义的异常变量，如果有子父类关系，子类的异常变量必须写在上面，否则就会报错) 3.多个异常，一次捕获，一次处理(一次try catch，使用Exception e就行，所有异常的父类)</p><p>如果finally中有return语句，永远返回的是finally中的结果，需要避免这种情况</p><p>子父类异常：父类异常什么样，子类异常就什么样：</p><p>(如果父类抛出多个异常，子类重写父类方法时，可以抛出和父类相同的异常，或者父类异常的子类或者不抛出异常；父类如果没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出)</p></blockquote><h5 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception/RuntimeException</span></span>&#123;<br>添加一个空参数非构造方法<br>添加一个带异常信息的构造方法<br>&#125;<span class="hljs-comment">//继承Exception，编译期异常，必须处理异常，throws或者try catch；继承RuntimeException，运行期异常，无需处理，交给虚拟机处理(中断处理)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegisterException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegisterException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">isInUsers</span><span class="hljs-params">(String user)</span> <span class="hljs-keyword">throws</span> RegisterException &#123;<br>        <span class="hljs-keyword">for</span> (String s : users) &#123;<br>            <span class="hljs-keyword">if</span>(s.equals(user))&#123;<br>               <span class="hljs-keyword">try</span>&#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegisterException</span>(<span class="hljs-string">&quot;该用户名已被使用&quot;</span>);<br>               &#125;<span class="hljs-keyword">catch</span>(RegisterException e)&#123;<br>                   e.printStackTrace();<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;恭喜注册成功！&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记3</title>
    <link href="/2025/08/04/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/"/>
    <url>/2025/08/04/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h5 id="Object类-java-lang-object"><a href="#Object类-java-lang-object" class="headerlink" title="Object类(java.lang.object)"></a>Object类(java.lang.object)</h5><blockquote><p>所有类的父类，所有类都可以使用Object类中的方法</p><p>都可以code+generate,自动生成@Override</p><p><strong>toString</strong></p><p>直接打印对象的名字，就是调用toString方法</p><p>scanner和ArrayList重写了toString方法，所以打印出来的东西不是地址值</p><p><strong>equals</strong></p><p>基本类型不能比较，引用类型比较地址值(a1.equals(a2)),返回布尔值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getClass() != o.getClass()<span class="hljs-comment">//判断是否与当前类的类型相同</span><br></code></pre></td></tr></table></figure><p>Objects类的equals方法：在对两个对象进行比较时，防止空指针异常</p><p>(a1.equals(a2) 当a1为null值时，就会发生空指针异常，NullPointerException)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;<br>        <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b));<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="日期时间类-java-util-date"><a href="#日期时间类-java-util-date" class="headerlink" title="日期时间类(java.util.date)"></a>日期时间类(java.util.date)</h5><blockquote><p><strong>Date</strong></p><p>表示特定的瞬间，精确到毫秒</p><p>时间原点(0毫秒)：1970年1月1日 00:00:00(英国格林威治)(中国是东八区，要加八个小时)</p><p><strong>System.currentTimeMills()</strong>：获取当前时间(毫秒)(long类型)</p><p>一天 &#x3D; 24<em>60</em>60 &#x3D; 86400秒 * 1000 &#x3D; 86400000毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-comment">//以下时间函数的使用需要创建对象</span><br></code></pre></td></tr></table></figure><p><strong>Date()</strong>:获取当前系统的日期和时间</p><p><strong>Date(long date)</strong>:传递毫秒值，把毫秒值转换为Date日期</p><p><strong>long getTime()</strong>:把日期转换为毫秒值(相当于System.currentTimeMills()方法)，返回自时间原点以来的毫秒值</p><p><strong>DateFormat(java.text.DateFormat)</strong>(抽象类)(直接已知子类：SimpleDateFormat)</p><blockquote><p>方法format：把日期格式转换为文本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd,HH:mm:ss&quot;</span>);<br></code></pre></td></tr></table></figure><p>方法parse:把文本解析为日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Date <span class="hljs-title function_">parse</span><span class="hljs-params">(String source)</span> <span class="hljs-keyword">throws</span> ParseException<br></code></pre></td></tr></table></figure><p>如果字符串和构造方法的博士不一样，程序就会抛出解析异常，要么throws继续抛出，要么try catch自己处理</p><p>红线异常用alt+enter抛出异常</p></blockquote><h5 id="Calendar-java-util-Calendar-抽象类"><a href="#Calendar-java-util-Calendar-抽象类" class="headerlink" title="Calendar(java.util.Calendar)(抽象类)"></a>Calendar(java.util.Calendar)(抽象类)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar <span class="hljs-number">111</span> = Calendar.getInstance();<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/39.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> c.get(Calendar.MONTH);<br></code></pre></td></tr></table></figure><p>西方的月份是0-11月</p><p>set的一个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">c.set(<span class="hljs-number">2019</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>);<span class="hljs-comment">//同时设置</span><br></code></pre></td></tr></table></figure><p>add方法的第二个参数，如果是正数就是加，负数就是减</p></blockquote><h5 id="System类-java-lang-System"><a href="#System类-java-lang-System" class="headerlink" title="System类(java.lang.System)"></a>System类(java.lang.System)</h5><blockquote><p><strong>System.currentTimeMills()</strong>：获取当前时间(毫秒)(long类型)</p><p>可以测试程序的效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.arraycopy(src, srcPos, dest, destPos, length);<br></code></pre></td></tr></table></figure><p>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。 </p></blockquote><h5 id="StringBuilder类-字符串缓冲区"><a href="#StringBuilder类-字符串缓冲区" class="headerlink" title="StringBuilder类(字符串缓冲区)"></a>StringBuilder类(字符串缓冲区)</h5><blockquote><p>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</p><p><img src="/img/cr/Java-SE/40.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">111</span>);<span class="hljs-comment">//无数据或者初始化字符串</span><br>sb.append(<span class="hljs-number">111</span>);<span class="hljs-comment">//可以添加任意内容</span><br>sb.toString(<span class="hljs-number">111</span>);<span class="hljs-comment">//StringBuilder转换为字符串，反转则是new StringBuilder(111);</span><br></code></pre></td></tr></table></figure><p>链式编程，可以一直.append()下去</p></blockquote><h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><blockquote><p><img src="/img/cr/Java-SE/41.png"></p><p>111.intValue();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//自动装箱</span><br>i = i + <span class="hljs-number">2</span>;<span class="hljs-comment">//自动拆箱</span><br></code></pre></td></tr></table></figure><p>ArrayList的.add()函数和.get()函数，其实就是自动装箱和自动拆箱</p><p><img src="/img/cr/Java-SE/42.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer.toString(<span class="hljs-number">111</span>);String.valueOf(<span class="hljs-number">111</span>);<br>Integer.parseInt(<span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure></blockquote><h5 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h5><blockquote><p>数组长度固定，集合长度可变</p><p>数组存储同一类型袁术，存储基本数据类型；集合存储对象，对象类型不一致</p><p><img src="/img/cr/Java-SE/43.png"></p></blockquote><h5 id="Collection常用功能"><a href="#Collection常用功能" class="headerlink" title="Collection常用功能"></a>Collection常用功能</h5><blockquote><p><img src="/img/cr/Java-SE/44.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>Object[] strArray = coll.toArray();<br></code></pre></td></tr></table></figure><p>remove函数只移除找到的第一个对象</p><p><strong>遍历方法</strong>：for循环、Iterator迭代器、增强for循环。无索引的集合不能用for循环</p></blockquote><h5 id="Iterator迭代器-111-Iterator-var"><a href="#Iterator迭代器-111-Iterator-var" class="headerlink" title="Iterator迭代器(111.Iterator().var)"></a>Iterator迭代器(111.Iterator().var)</h5><blockquote><p><strong>迭代</strong>：即Collection集合元素的通用获取方式。在区元素之前先判断集合中有没有元素，如果有，取元素，继续判断，继续取元素，一直到把集合中所有的元素全部取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;Integer&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        Iterator&lt;Integer&gt; itrt = coll.iterator();<br>        <span class="hljs-keyword">while</span>(itrt.hasNext())&#123;<br>            System.out.print(itrt.next()+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br></code></pre></td></tr></table></figure><p>创建iterator的实现类对象时，会把指针指向集合的-1索引</p><p>hasnext()判断集合有没有下一个元素，next()做了两件事情：1.取出下一个元素  2.把指针向后移动一位</p></blockquote><h5 id="增强for循环-111-for"><a href="#增强for循环-111-for" class="headerlink" title="增强for循环(111.for)"></a>增强for循环(111.for)</h5><blockquote><p>也称for each循环，内部原理是Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(集合/数组的数据类型 变量名：集合名/数组名)&#123;<br>sout(变量名);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(String i:coll)&#123;<br>            System.out.println(i);<br>        &#125;<br></code></pre></td></tr></table></figure><p>新for循环必须有被遍历的目标，目标只能是Collection或者数组</p></blockquote><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><blockquote><p>一种未知的数据类型，当我们不知道使用什么数据类型，就可以使用泛型</p><p>泛型也可以看做是一个变量，用来接受数据类型</p><p>E e:Element 元素         T t:Type 类型</p><p>创建集合对象，不使用泛型：默认类型是Object类型，可存储任意类型的数据；不安全，会引发异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArrayList</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<span class="hljs-comment">//不写尖括号就是默认Object类型</span><br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/45.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class <span class="hljs-number">111</span>&lt;E&gt;&#123;&#125;<span class="hljs-comment">//泛型类</span><br><span class="hljs-keyword">public</span> &lt;M&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(M m)</span>&#123;&#125;<span class="hljs-comment">//泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(S s)</span>&#123;&#125;<span class="hljs-comment">//泛型静态方法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenericInter</span>&lt;I&gt; &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(I i)</span>;<span class="hljs-comment">//泛型接口的实现类有两种实现方法</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInter</span>&lt;String&gt;<span class="hljs-comment">//一种是在类的实现时就定义数据类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericInterImp2</span>&lt;I&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenericInter</span>&lt;I&gt;<span class="hljs-comment">//一种是在类的实现时不定义数据类型，使用时才定义数据类型</span><br></code></pre></td></tr></table></figure><h5 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h5><p>不知道使用什么类型来接收时，可以使用？，？代表未知通配符</p><p>只能接受数据，不能往集合中存储数据(只能作为参数传递，不能在创建数据时使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(ArrayList&lt;?&gt; array)</span>&#123;<br>     Iterator&lt;?&gt; itrt = array.iterator();<br> &#125;<br></code></pre></td></tr></table></figure><h5 id="通配符高级使用：受限泛型"><a href="#通配符高级使用：受限泛型" class="headerlink" title="通配符高级使用：受限泛型"></a>通配符高级使用：受限泛型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类型名称 &lt;? extends 类&gt; 对象名称<span class="hljs-comment">//泛型上限：只能接受该类型及其子类</span><br>类型名称 &lt;? <span class="hljs-built_in">super</span> 类&gt; 对象名称<span class="hljs-comment">//泛型下限：只能接受该类型及其父类</span><br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/46.png"></p><p>会看就行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.shuffle(poker);<span class="hljs-comment">//collections混合排序方法</span><br></code></pre></td></tr></table></figure><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><blockquote><p>数据存储常用结构：栈、队列、数组、链表和红黑树</p><h5 id="栈：先进后出"><a href="#栈：先进后出" class="headerlink" title="栈：先进后出"></a>栈：先进后出</h5><h5 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h5><p><img src="/img/cr/Java-SE/47.png"></p><h5 id="数组：查询快，增删慢"><a href="#数组：查询快，增删慢" class="headerlink" title="数组：查询快，增删慢"></a>数组：查询快，增删慢</h5><p><img src="/img/cr/Java-SE/48.png"></p><h5 id="链表：查询慢，增删快"><a href="#链表：查询慢，增删快" class="headerlink" title="链表：查询慢，增删快"></a>链表：查询慢，增删快</h5><p><img src="/img/cr/Java-SE/49.png"></p><h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><p><img src="/img/cr/Java-SE/50.png"></p></blockquote><h5 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h5><blockquote><h5 id=""><a href="#" class="headerlink" title=""></a><img src="/img/cr/Java-SE/51.png"></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h5 id="实现类：ArrayList集合、LinkedList集合"><a href="#实现类：ArrayList集合、LinkedList集合" class="headerlink" title="实现类：ArrayList集合、LinkedList集合"></a>实现类：ArrayList集合、LinkedList集合</h5><p>ArrayList集合数据存储的结构是<strong>数组结构</strong>，结合数组的特点，不应该用于增删操作多的地方</p><p>LinkedList是<strong>链表结构</strong>，使用LinkedList集合特有的方法，不能使用多态</p><p><img src="/img/cr/Java-SE/52.png"></p><p>还有addLast()等效于add()</p><p>ll.clear()清空</p><h5 id="Vector集合-底层数组，单线程慢-了解就行"><a href="#Vector集合-底层数组，单线程慢-了解就行" class="headerlink" title="Vector集合(底层数组，单线程慢)(了解就行)"></a>Vector集合(底层数组，单线程慢)(了解就行)</h5><p>addElement();hasMoreElement();nextElement();elements();</p></blockquote><p>Set接口</p><blockquote><p>Set接口的方法和Collections的方法一样</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>特点：</p><p>super(Collections);</p><p>1.是一个无序的集合，存储元素和取出元素的顺序有可能不一致</p><p>2.底层是一个哈希表结构(查询的速度非常快)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p><strong>哈希值</strong>：是一个十进制的整数，由系统随机给出</p><p>(就是对象的地址值，是一个逻辑地址，是模拟出来得到的地址，不是数据实际存储的物理地址)</p><p>int hashCode() 返回该对象的哈希值</p><blockquote><p>public native int hashCode();(native代表该方法调用的是本地操作系统的方法)</p><p>Stirng类重写了hashCode()方法，”重地”和”通话”字符串不一样，但是哈希值一样</p></blockquote><h5 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h5><p><img src="/img/cr/Java-SE/53.png"></p><p>set结合在调用add方法时，会调用元素的hashCode方法和equals方法，判断元素是否重复</p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>底层是一个哈希表(数组+链表&#x2F;红黑树)+链表：多了一条链表(记录元素的存储顺序),保证元素有序</p><p><strong>可变参数</strong></p><p>当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(数据类型...变量名)&#123;&#125;<br></code></pre></td></tr></table></figure><p>可变参数底层是一个数组，根据参数个数不要，会创建不同长度的数组，来存储这些参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">int</span>...c)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(Object...obj)</span>&#123;&#125;<span class="hljs-comment">//可变参数的特殊(终极)写法</span><br></code></pre></td></tr></table></figure><p>1.一个方法的参数列表，只能有一个可变参数</p><p>2.如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记2</title>
    <link href="/2025/08/01/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2025/08/01/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h5 id="Arrays相关函数"><a href="#Arrays相关函数" class="headerlink" title="Arrays相关函数"></a>Arrays相关函数</h5><blockquote><p>toString:将参数数组变成字符串</p><p>sort:按照升序排列数组元素(直接在原数组上排序)</p><p>(如果是自定义的类，需要有Comparable或者Comparator接口的支持)</p></blockquote><h5 id="Math相关函数"><a href="#Math相关函数" class="headerlink" title="Math相关函数"></a>Math相关函数</h5><blockquote><p><img src="/img/cr/Java-SE/30.png"></p><p>四舍五入不带小数点</p><p>Math.PI</p></blockquote><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p>继承主要解决的问题是：共性抽取</p><p>父类也可以叫基类、超类；子类也可以叫派生类</p><p>有子用子，无子找父</p><p>子类对象  使用父类方法中  调用的数据是父类的(在父类中定义的)</p><p><img src="/img/cr/Java-SE/31.png"></p><p>重写(Override):方法名称和参数列表都一样，重载参数列表不一样(@Override)</p><p>返回值范围：子类方法【小于等于】父类方法</p><p>权限：子类方法【大于等于】父类方法(public&gt;protected&gt;(default)(留空的意思)&gt;private)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>()&#123;<br><span class="hljs-built_in">super</span><span class="hljs-number">.111</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>子类构造方法中有一个默认隐含的“super()；”调用，所有一定是先执行父类构造，后执行子类构造，且只能有一个super()；调用父类构造方法，且必须是构造方法第一句</p><p>可以通过super关键字  从子类  构造  父类的重载构造</p><p><img src="/img/cr/Java-SE/32.png"></p><p><img src="/img/cr/Java-SE/33.png"></p><p><img src="/img/cr/Java-SE/34.png"></p><p>单继承、多级继承、多继承</p></blockquote><h5 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h5><blockquote><p>如果父类中的方法不确定如何实现，就是一个抽象方法</p><p>抽象方法所在的类必须是抽象类，但抽象类中不一定有抽象方法，这种抽象类也不能直接创建对象，在一些特殊场景下有用途</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> class <span class="hljs-number">111</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>不能直接创建抽象类对象，抽象类必须由子类继承后，<strong>将所有抽象方法覆盖重写</strong>(去掉abstarct关键词实现)，如果抽象方法没有全部覆盖重写成非抽象方法，那么这个子类也是抽象类</p><p>抽象父类可以有构造方法，但那是在  创建子类对象时  调用子类构造方法中  的super();时  使用的</p></blockquote><h5 id="发红包问题的分析"><a href="#发红包问题的分析" class="headerlink" title="发红包问题的分析"></a>发红包问题的分析</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">发红包的逻辑<br>返回值  ArrayList&lt;Double&gt;<br>名称  send<br>参数列表  ArrayList&lt;Double&gt;<br><br>收红包的逻辑<br>返回值  ArrayList&lt;Double&gt;<br>名称  recieve<br>参数列表  ArrayList&lt;Double&gt;<br><br>用户类：姓名，余额-&gt;群主类：姓名，余额，send;群员类：姓名，余额，id,n(与idCounter类似),recieve<br></code></pre></td></tr></table></figure></blockquote><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><blockquote><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的就是其中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface 接口名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口的字节码文件仍然是.class文件</p><p>java7:1.常量  2.抽象方法  java8:3.默认方法  4.静态方法  java9：5.私有方法</p><h5 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h5><p>修饰符必须是两个固定的关键词：public abstract(这两个都可以选择性的省略)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>();<br></code></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>1.接口不能直接使用，必须有一个实现类来实现该接口，创建实现类的对象进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 实现类名称 implements 接口名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.接口的实现类必须覆盖重写接口中所有的抽象方法，如果实现类没有完全覆盖接口中的抽象方法，这个实现类必须是抽象类</p><p>3.接口不能有静态代码块或者构造方法</p><p>4.一个类的父类是唯一的，但是一个类可以同时实现多个接口</p><p>5.如果接口中有重复的抽象方法，只用覆盖重写一次就行；有重复的默认方法，必须对冲突的默认方法进行覆盖重写</p><p>6.直接父类和接口中的方法产生冲突，优先只 使用父类的方法</p><p>7.类与类单继承，类与接口多实现，接口与接口多继承</p><p><strong>默认方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法库通过接口实现类对象直接调用，也可以被接口实现类进行覆盖重写</p><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不能通过接口实现类的对象  来调用接口当中的静态方法，应该使用接口名称调用(不用创建类和对象)</p><h5 id="私有方法-分为默认和静态两种，静态私有方法-解决-多个静态方法之间重复代码-的问题"><a href="#私有方法-分为默认和静态两种，静态私有方法-解决-多个静态方法之间重复代码-的问题" class="headerlink" title="私有方法(分为默认和静态两种，静态私有方法  解决  多个静态方法之间重复代码  的问题)"></a>私有方法(分为默认和静态两种，静态私有方法  解决  多个静态方法之间重复代码  的问题)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> (<span class="hljs-keyword">static</span>) 返回值类型 方法名称(参数列表)&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>必须使用public static final三个关键词修饰，可以省略，但是意思不变</p><p>一旦使用final关键字，说明不可改变，也因此该常量必须进行赋值(定义名称规范：INT_NUM)</p></blockquote><h5 id="多态-对象的多态性"><a href="#多态-对象的多态性" class="headerlink" title="多态(对象的多态性)"></a>多态(对象的多态性)</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类名称 对象名 = <span class="hljs-keyword">new</span> 子类名称();<br>接口名称 对象名 = <span class="hljs-keyword">new</span> 实现类名称();<br></code></pre></td></tr></table></figure><p>当父类和子类有相同方法时，<strong>看new的是谁实现谁的方法</strong>，这里new的是子类，所以实现子类的方法</p><p>只有方法能被<strong>覆盖重写，成员变量不行</strong>，所以使用对象名访问成员变量时，看左边是谁优先用谁，没有则向上找</p><p>间接通过成员方法访问成员变量，方法属于谁优先用谁，没有则向上找</p><p>成员变量：编译看左边，运行还看左边</p><p>成员方法：编译看左边，运行看右边</p><p><img src="/img/cr/Java-SE/35.png"></p><p>使用多态的方法，就可以统一右边的语句，看起来规整</p><p><strong>对象的向上转型</strong>(父类名称 对象名 &#x3D; new 子类名称();)</p><p>子类就只能使用父类中已经定义的方法，限制子类动作(一定安全：小范围-&gt;大范围)</p><p><strong>对象的向下转型</strong>(子类名称 新对象名 &#x3D; (子类名称) 原对象名;)</p><p>必须本来是这个子类，才能还原为这个子类(java.lang.ClassCastException类转换异常)</p><p>(对象名 instanceof 子类名称)返回一个boolean值，判断对象是不是该类型的实例</p><p>使用接口作为方法参数，但是传进去的是该接口的实现类时，会自动向上转型为接口</p></blockquote><h5 id="final-最终的，不可该变的"><a href="#final-最终的，不可该变的" class="headerlink" title="final(最终的，不可该变的)"></a>final(最终的，不可该变的)</h5><blockquote><p>类(不能有任何的子类，所有成员方法都无法被覆盖重写)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> class <span class="hljs-number">111</span>&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>方法(不能被覆盖重写)(类与方法中都不能将abstract和final同时使用)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-number">111</span>()&#123;<br><span class="hljs-number">111</span><br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量(一次赋值，终身不变)(基本类型数据不变，引用类型地址值不变)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> 数据类型 <span class="hljs-number">111</span> = <span class="hljs-number">111</span>;<br></code></pre></td></tr></table></figure><p>成员变量(必须手动赋值，因为不赋值的话成员变量会自动赋空值)(构造赋值和直接复制二选一)</p><p>(必须保证类当中所有重载的构造方法，都最终回嘴final的成员变量进行赋值)</p></blockquote><h5 id="权限修饰符：-public-protected-default-留空的意思-private"><a href="#权限修饰符：-public-protected-default-留空的意思-private" class="headerlink" title="权限修饰符：           public&gt;protected&gt;(default)(留空的意思)&gt;private"></a>权限修饰符：           public&gt;protected&gt;(default)(留空的意思)&gt;private</h5><blockquote><p>同一个类：             Yes           Yes             Yes                                   Yes</p><p>同一个包:                Yes           Yes             Yes                                   No</p><p>不同包子类：          Yes           Yes             No                                   No</p><p>不同包非子类：      Yes           No             No                                   No</p></blockquote><h5 id="内部类-成员内部类和局部内部类-包含匿名内部类"><a href="#内部类-成员内部类和局部内部类-包含匿名内部类" class="headerlink" title="内部类(成员内部类和局部内部类(包含匿名内部类))"></a>内部类(成员内部类和局部内部类(包含匿名内部类))</h5><blockquote><h5 id="成员内部类-在方法外面"><a href="#成员内部类-在方法外面" class="headerlink" title="成员内部类(在方法外面)"></a>成员内部类(在方法外面)</h5></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 Class 外部类名称&#123;<br>修饰符 class 内部类名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>内用外，随意访问；外用内，需要内部类对象</p><p>使用方式：1.通过外部类对象，调用外部类的方法，在里面间接使用内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2.</span>外部类名称.内部类名称 对象名 = <span class="hljs-keyword">new</span> 外部类名称().new 内部类名称();<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/36.png"></p><h5 id="局部内部类-在方法里面"><a href="#局部内部类-在方法里面" class="headerlink" title="局部内部类(在方法里面)"></a>局部内部类(在方法里面)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 Class 外部类名称&#123;<br>修饰符 返回值类型 外部类方法名称(参数列表)&#123;<br>  修饰符 class 内部类名称&#123;<br><span class="hljs-number">111</span><br>&#125;<br>  内部类名称 <span class="hljs-number">111</span> = <span class="hljs-keyword">new</span> 内部类名称();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/37.png"></p><p>局部内部类，如果希望访问所在方法的局部变量，这个局部变量必须是<strong>有效final</strong>的(不能改变)</p><p>(从java8+开始，只要局部变量事实不变，那么final关键字可以省略)</p><p>原因：1.new出来的对象在<strong>堆内存</strong>中，垃圾回收才会消失</p><p>​   2.局部变量跟着方法走，而方法在<strong>栈内存</strong>中，方法运行入栈，运行结束出栈，局部变量就      会立即消失</p><h5 id="匿名内部类-局部内部类中的"><a href="#匿名内部类-局部内部类中的" class="headerlink" title="匿名内部类(局部内部类中的)"></a>匿名内部类(局部内部类中的)</h5><p>如果接口的实现类(或者父类的子类)只需要使用唯一的一次，就可以忽略该类的定义，使用匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">接口名称 对象名 = <span class="hljs-keyword">new</span> 接口名称()&#123;<br><span class="hljs-comment">//覆盖重写所有抽象方法</span><br>&#125;;<span class="hljs-comment">//匿名内部类</span><br><span class="hljs-keyword">new</span> 接口名称()&#123;<br>修饰符 返回值类型 <span class="hljs-number">111</span>()&#123;<br>  <span class="hljs-number">111</span><br>&#125;<br>&#125;<span class="hljs-number">.111</span>();<span class="hljs-comment">//匿名内部类，也是匿名对象</span><br></code></pre></td></tr></table></figure><p><strong>注意不要丢了分号</strong></p><p><img src="/img/cr/Java-SE/38.png"></p></blockquote><h5 id="成员变量补充"><a href="#成员变量补充" class="headerlink" title="成员变量补充"></a>成员变量补充</h5><blockquote><p>成员变量不仅可以为数据类型，还可为类class，接口也可以为成员变量的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> 数据类型 数据名称;<br><span class="hljs-keyword">public</span> class 类名称&#123;&#125;<br>类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 数据类型 方法名称();<br><span class="hljs-keyword">public</span> class 类名称 implements 接口名称&#123;<span class="hljs-meta">@Override</span>&#125;<br>类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称();<br></code></pre></td></tr></table></figure><p>使用单独定义的实现类&#x2F;使用匿名内部类&#x2F;同时使用匿名内部类和匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名称.set数据名称(<span class="hljs-keyword">new</span> 类名称());<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">类名称 对象名称 = <span class="hljs-keyword">new</span> 类名称()&#123;<span class="hljs-meta">@Override</span>&#125;&#125;;<br>对象名称.set数据名称(<span class="hljs-number">111</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名称.set数据名称(<span class="hljs-keyword">new</span> 类名称()&#123;<span class="hljs-meta">@Override</span>&#125;);<br></code></pre></td></tr></table></figure><p>接口可以作为方法的参数和返回值</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-SE学习笔记1</title>
    <link href="/2025/07/27/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2025/07/27/Java-SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h5 id="十进制和二进制之间的转换"><a href="#十进制和二进制之间的转换" class="headerlink" title="十进制和二进制之间的转换"></a>十进制和二进制之间的转换</h5><blockquote><p><img src="/img/cr/Java-SE/2.png"></p><p>HEX-&gt;十六进制；DEC-&gt;十进制；OCT-&gt;八进制；BIN-&gt;二进制</p></blockquote><h5 id="计算机存储单位："><a href="#计算机存储单位：" class="headerlink" title="计算机存储单位："></a>计算机存储单位：</h5><blockquote><p><img src="/img/cr/Java-SE/4.png"></p><p><img src="/img/cr/Java-SE/1.png"></p></blockquote><h5 id="JDK、JRE和JVM之间的关系"><a href="#JDK、JRE和JVM之间的关系" class="headerlink" title="JDK、JRE和JVM之间的关系:"></a>JDK、JRE和JVM之间的关系:</h5><blockquote><p><img src="/img/cr/Java-SE/3.png"></p></blockquote><h5 id="HelloWord代码的编译运行："><a href="#HelloWord代码的编译运行：" class="headerlink" title="HelloWord代码的编译运行："></a>HelloWord代码的编译运行：</h5><blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">javac HelloWorld.java<br>java HelloWorld<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World!!!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="关键字、标识符和常量："><a href="#关键字、标识符和常量：" class="headerlink" title="关键字、标识符和常量："></a>关键字、标识符和常量：</h5><blockquote><p><img src="/img/cr/Java-SE/8.png"></p><p><img src="/img/cr/Java-SE/9.png"></p><ul><li><p>两个单引号之间不能什么都没有，也不能有两个及以上个字符</p></li><li><p>空常量不能直接打印输出</p></li></ul></blockquote><h5 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h5><blockquote><p><img src="/img/cr/Java-SE/10.png"></p><p><img src="/img/cr/Java-SE/11.png"></p></blockquote><p><img src="/img/cr/Java-SE/12.png"></p><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><blockquote><p>自动和强制，自动类型转换必须是范围小的转换成范围大的</p><p>强制类型转换一般不推荐使用，可能会发生精度损失和数据溢出</p><p>byte&#x2F;short&#x2F;char在进行运算时，先变成int类型，再进行运算</p><p>boolean类型不能发送数据类型转换</p></blockquote><h5 id="ascii码"><a href="#ascii码" class="headerlink" title="ascii码"></a>ascii码</h5><blockquote><p>48-&gt;0;65-&gt;A;97-&gt;a</p><p><img src="/img/cr/Java-SE/13.png"></p></blockquote><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><blockquote><p>运算时类型不统一时，结果会是数据类型范围大的那一个（字符串和任何数据类型连接都会变成字符串）</p><p>对于字符串，+号相当于拼接符</p><p>只有变量才能自增自减和赋值，常量不行</p><p>三元运算翻译必须两个表达式都符合左侧数据类型的要求</p><p>三元运算符的结果必须被使用</p><p>对于byte&#x2F;short&#x2F;char类型，如果右侧赋值的数值没有超过范围，javac编译器自动强制转换（byte）&#x2F;（short）&#x2F;（char）</p><p>赋值时右侧表达式全是常量，javac编译器直接得到结果，存储结果而非表达式</p></blockquote><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><blockquote><p><img src="/img/cr/Java-SE/14.png"></p><p>do while循环的while后的分号不能忘记</p><p>死循环标准格式：while(true){}</p></blockquote><h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><blockquote><p><img src="/img/cr/Java-SE/15.png"></p><p>shift+f6  相同内容同时修改</p><p>psvm、5.fori、array.fori</p></blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>方法重载：方法名称一样，参数列表不一样（个数、类型、多类型顺序）（与方法返回值类型和参数名称无关）</p></blockquote><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><blockquote><h5 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h5><blockquote><p>类型统一且长度不可变</p><p>动态初始化数组（创建数组时直接指定数据个数多少）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrayA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br></code></pre></td></tr></table></figure><p>静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arrayB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;sddf&quot;</span>, <span class="hljs-string">&quot;gdd&quot;</span>&#125;;<br><span class="hljs-type">int</span>[] arrayC = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>动态初始化数组可以拆分成两步，而动态初始化不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arrayA;<br>arrayA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">300</span>];<br></code></pre></td></tr></table></figure><p>直接打印数组，得到的是数组对应的内存地址哈希值</p><p><img src="/img/cr/Java-SE/16.png"></p></blockquote><h5 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h5><blockquote><p><img src="/img/cr/Java-SE/17.png"></p><p><img src="/img/cr/Java-SE/18.png"></p><p><img src="/img/cr/Java-SE/19.png"></p><p>所以叫引用类型</p></blockquote><h5 id="数组异常"><a href="#数组异常" class="headerlink" title="数组异常"></a>数组异常</h5><blockquote><p>如果访问数组元素的时候，索引编号并不存在，那么将会发生</p><p>数组索引越界异常</p><p>ArrayIndexOutOfBoundsException</p><p>数组没有进行new初始化，就会发生</p><p>空指针异常</p><p>NullPointerException</p></blockquote><h5 id="数组函数使用"><a href="#数组函数使用" class="headerlink" title="数组函数使用"></a>数组函数使用</h5><blockquote><p>获取数组的长度：array.length</p><p>遍历输出数组所有的值</p><p>Arrays.toString(111)数组转换为字符串</p></blockquote></blockquote><h5 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h5><blockquote><p>成员变量直接定义在类中，方法外面</p><p>成员方法不要写static关键字</p><p>类名称 对象名 &#x3D; new 类名称（）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><p><img src="/img/cr/Java-SE/20.png"></p><p>注意：方法并不是直接存放在堆里面，堆里面存放的只是堆在方法区的内存地址</p><p>当一个对象作为参数，传递到方法中时，实际上传递进去的是对象的地址值</p><p>对象作为返回值时，返回的值也是对象的地址值</p><p><img src="/img/cr/Java-SE/21.png"></p></blockquote><h5 id="类与对象-1"><a href="#类与对象-1" class="headerlink" title="类与对象"></a>类与对象</h5><blockquote><p>面向对象三大特征：封装、继承、多态</p><p>方法就是一种封装；private关键字也是一种封装</p><p>间接访问private成员变量，就是定义一对setter&#x2F;getter方法</p><p>boolean类型的getter方法不能写get111，要写is111</p><p>this.成员变量名，访问本类中的成员变量</p><p>构造方法：</p><p><img src="/img/cr/Java-SE/22.png"></p><p>即使全参构造方法中已经存在this.111 &#x3D; 111;依然需要setter方法，方便后续修改</p><p>标准的类（Java bean）：所有成员变量都用的private修饰、无参方法、全参方法、每个成员变量都要用getter&#x2F;setter修饰</p><p>构造方法、getter&#x2F;setter自动补全：Code-&gt;Generate</p></blockquote><h5 id="Scanner、匿名对象、Random、ArrayList"><a href="#Scanner、匿名对象、Random、ArrayList" class="headerlink" title="Scanner、匿名对象、Random、ArrayList"></a>Scanner、匿名对象、Random、ArrayList</h5><blockquote><p>合理使用api文档，只有java.lang包下的内容不需要导包，其他都需要</p><p>引用类型的一般使用步骤：1.导包：地址.类名2.创建：类名称 对象名 &#x3D; new 类名称();3.使用：对象名.成员方法名</p><p><img src="/img/cr/Java-SE/23.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> sc.nextInt();<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.next();<br></code></pre></td></tr></table></figure><p>匿名对象：只使用唯一的一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>().name = <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>().showName();<br></code></pre></td></tr></table></figure><p>Random:.nextint()<strong>整个int范围</strong>；nextint(111)<strong>0(包括)到111(不包括)随机生成int数字</strong></p><p>数组长度不可改变，Arraylist长度可以改变</p><p>ArrayList<E>： <strong><E>代表泛型，且只能是引用类型，不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>对于ArrayList，直接打印得到的不是地址，而是内容。如果内容为空，得到的是空的中括号：[]</p><p>list.add(111)添加元素；list.get(111)查看元素；list.remove移除元素；list.size()获取长度</p><p>想要存储基本类型就要使用包装类，包装类名称为首字母大写(如byte-&gt;Byte,特殊：int-&gt;Integer;char-&gt;Character)</p></blockquote><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><blockquote><p>字符串是常量，他们的值在创建后不能更改，所以字符串可以共享使用</p><p>字符串效果上是char[]字符数组，但是底层原理是一个byte[]字节数组</p><p><img src="/img/cr/Java-SE/24.png"></p><p>注意：直接写上双引号，就是字符串对象（jvm帮忙new了）</p><p>字符串常量池：程序中只有直接写上双引号的字符串，才放在字符串常量池中</p><p>对于基本类型：&#x3D;&#x3D;进行数值的比较</p><p>对于引用类型：&#x3D;&#x3D;进行地址值的比较</p><p><img src="/img/cr/Java-SE/25.png"></p><p>要进行字符串内容的比较，使用函数：equals(Object obj)参数可以是任何对象，但只有参数是一个字符串且内容相同时才会给false。</p><p>str1.equals(str2)：str1不能为null值，会造成空指针异常；str2可以，只会warning不会报错。因此str1最好为常量，str2为变量</p><p>equalsIgnoreCase(String str)忽略大小写，进行内容比较</p><p><img src="/img/cr/Java-SE/26.png"></p><p><strong>substring</strong>: substring(int index);  substring(int begin,int end)(<strong>(begin,end]</strong>)</p><p>数字符索引值，从0开始，一个右箭头加一，切割想要的单词时，按住shift键右箭头继续加一</p><p><img src="/img/cr/Java-SE/27.png"></p><p>切割字符串：split(String regex)  切割为一个字符串数组</p><p>如果以”.”切割，必须以”\.”切割，否则切割不成功</p></blockquote><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><blockquote><p>使用static关键字，内容属于类，凡本类对象都共享一份</p><p>修饰成员变量如共同教室，idCoounter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">idCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-number">111</span>)</span> &#123;<br>    <span class="hljs-number">111</span><br>    id = ++idCounter;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br>    id = ++idCounter;<br>&#125;<br></code></pre></td></tr></table></figure><p>普通方法可以用<em>对象名.方法名</em>使用，静态方法还可以使用<em>类名.静态方法名</em>使用(推荐)</p><p><img src="/img/cr/Java-SE/28.png"></p><p><img src="/img/cr/Java-SE/29.png"></p><p>静态代码块：(静态内容总是优先于非静态内容)(第一次使用本类时执行唯一的一次)</p><p>常用用图：一次性地对静态成员变量进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名称&#123;<br><span class="hljs-keyword">static</span>&#123;<br><span class="hljs-number">111</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客日常更新指令</title>
    <link href="/2025/07/15/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E6%8C%87%E4%BB%A4/"/>
    <url>/2025/07/15/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%B8%B8%E6%9B%B4%E6%96%B0%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>指令集合：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">npx hexo cl&amp;<span class="hljs-variable">&amp;npx</span> hexo g&amp;<span class="hljs-variable">&amp;npx</span> hexo s<br>(清除缓存+生成更改+测试网页)<br>npx hexo d<br>(推送到服务器)<br></code></pre></td></tr></table></figure><p>记得ctrl+f5强制刷新</p><p>参数运用：</p><p><img src="/img/cr/1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
